# 决策树

**决策树（Decision Tree)**是一种用于分类的机器学习算法，他根据表示示例(example)的属性，对属性进行选择并作出判断，将训练数据根据这个属性测试的结果被划分到子节点中。生成决策树的过程是一个递归生成的过程，遵循简单而直观的“分而治之”策略，基本算法如下:
$$
\begin{split}
输入:&训练集 D=\{(x_1,y_1),(x_2, y_2),\cdots,(x_m,y_m)\};\\
\quad &属性集A=\{a_1, a_2,\cdots,a_d\}
\end{split}
$$

```
过程:函数TreeGenerate(D,A)
生成节点node
if D中样本全部属于一个类别C then
	将node标记为C类叶节点；
	return
end if
if A=null OR D中样本在A上取值相同 then
	将node标记为叶节点，其类别标记为D中样本数最多的类；
	return；
end if
从A中选择最有划分属性a*; //这一步是判别树的关键
for a*的每一个值b do
	为node生成一个分之，令Dv表示D在a*上取值为b的样本子集
	if Dv为空 then
		将分支节点标记为叶节点，其类别标记为D中样本最多的类；
		return
	else
		以TreeGenerate(Dv,A\{b}) 为分支节点
	end if
end for
```



* 涉及主要公式：

  1. 信息熵
     $$
     Ent(D)=-\sum_{k=1}^{k=y}p_k log p_k
     $$

  2. 信息增益
     $$
     Gain(D, a) = Ent(D) - \sum_{v=1}^v\frac{|D^v|}{|D|}Ent(D^v)
     $$

  3. 增益率
     $$
     Gain_ratio = \frac{Gain(D, a)}{IV(a)} \\
     其中IV(a)称为固有值，其定义如下:\\
     IV(a) = -\sum_{v=1}^{v}\frac{|D^v|}{|D|} log \frac{|D^v|}{|D|}
     $$

  4. 基尼值
     $$
     \begin{split}
     Gini(D) = &\sum_{k=1}^{y} \sum_{k'\neq k} p_k p_{k'}\\
     		=&\sum_{k=1}^{y}  p_k (1-p_k)\\
     		=&\sum_{k=1}^y p_k - \sum_{k=1}^{y}p_k^2\\
     		=&1 -  \sum_{k=1}^{y}p_k^2
     \end{split}
     $$

  5. 基尼指数
     $$
     Gini_index(D, a) = \sum_{v=1}^{v}\frac{|D^V|}{|D|}Gini(D^v)
     $$


## 1、信息增益

使用信息增益来作为选择判断依据的主要算法是ID3

首先申明在这里没有特别申明的情况下，我们样本的每个属性的取值都是离散值。同时我们预先定义好几个全局符号:

* $D=\{(x_1,y_1),(x_2, y_2),\cdots,(x_m,y_m)\}$表示样本集合
* $p_k(k=1, 2,\cdots,|y|)$表示样本集合D中第$k$类样本所占的比例
* 离散属性$a$的取值记为${a^1, a^2,\cdots,a^v}$
* 样本集合D在属性a的第$v$个属性$a^v$的分支节点记为$D^v$;

**纯度(purity)**是用来度量决策树的分支节点所包含的样本属于同一类别的方式，我们希望节点的纯度越高越好，即分支节点的样本尽可能地属于同一类别。**信息熵(information entropy)**是度量样本集合纯度最常用的一种指标，这个值越小表示集合的纯度越高。

样本集合$D$的信息熵定义为:
$$
Ent(D)=-\sum_{k=1}^{|y|}p_k log p_k\quad(公式1)
$$
$Ent(D)$的值越小， 则D的纯度越高，在这里，约定当$p_k=0时,p_k log p_k =0$,$Ent(D)$的取值范围为$[0,log_2|y|]$.

样本集合D在属性$a$进行划分，获得的**信息增益(information gain)**表示为:
$$
Gain(D, a)=Ent(D) - \sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)\quad(公式2)
$$
基本思路:

1. 计算当前节点的信息熵$Ent(D)$;
2. 计算按属性a划分后各个子节点的信息熵$Ent(D^v)$
3. 计算各个子节点的权重$\frac{|D^v|}{|D|}$,主要考虑到每个节点包含的样本数不同。
4. 当前节点的信息熵 - 所有子节点的信息熵×权重

一般而言，信息增益越大，意味着使用属性a来进行划分，所获得的“纯度提升”越大，当前节点选择的属性，在他的后续子节点中不再参与属性选择。

## 2、 增益率

著名的算法有C4.5

信息增益准则对可取值数目较多的属性有所偏好，为减少这种偏好的带来的影响，人们提出了**增益率(gain ratio)**来选择最有划分属性，其定义如下:
$$
Gain_ratio(D, a)=\frac{Gain(D, a)}{IV(a)}\quad(公式3)
$$
其中
$$
IV(a)=-\sum_{v=1}^{V}\frac{|D^v|}{|D|} log \frac{|D^v|}{|D|}\quad(公式4)
$$
$IV(a)$称为属性a的**固有值(intrinsic value)**,当属性a的可能取值数目越多（即V越大），则$IV(a)$的值通常越大。所以增益率准则对可取值数目较少的属性有所偏好。

由于增益率这一特点，C4.5没有直接使用增益率，而实现从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的。

## 3、 基尼指数

**CART**(classification and Regression Tree)使用**基尼指数**(Gini index)来选择划分属性，数据集D的纯度用基尼值来进行度量：
$$
\begin{split}
Gini(D)=&\sum_{k=1}^{|y|}\sum_{k'\neq k}p_kp_{k'} \\
=&\sum_{k=1}^{|y|}p_k(1-p_k)\\
=&\sum_{k=1}^{|y|}p_k - \sum_{k=1}^{|y|}p_k^2\\
=&1 - \sum_{k=1}^{|y|}p_k^2
\end{split}\quad(公式5)
$$
从公式中，我们可以直观的发现Gini(D)反映了从数据集中随机抽取两个样本，其类别标记不一致的概率，因此，$\textbf{Gini(D)}$**越小，则数据集D的纯度越高**。

基于属性a的基尼指数为:
$$
Gini_index(D, a)= \sum_{v=1}^V \frac{|D^v|}{|D|}Gini(D^v)\quad(公式6)
$$
从公式可以看出基尼指数就是当前节点按属性a进行划分后，各个子节点的基尼值的加权和。我们选择那个划分后基尼指数最小的的属性进行划分。

## 4、 剪枝处理

**剪枝**(pruning)是决策树学习算法对付过拟合的主要方法，分为**预剪枝**(prepruning)和**后剪枝**(postpruning)两种，预剪枝是指在决策树生成过程中，对每个节点在划分前后进行评估，若化分前后得不到泛华性能（根据验证集数据计算）提升，则停止划分，将当前节点作为叶节点；后剪枝则是先从训练数据生成一棵完整的决策树，然后**自底向上**对非叶节点进行考察若将他的子树替换为叶节点能带来泛华能力的提升，则将该子树替换为叶节点。

对于预剪枝，在选择某一属性作为候选划分属性时，使用验证集数据来对划分前后的泛化能力（在验证机上计算正确率）进行测试，若得不到泛华能力的提升，则该节点不进行划分。这种方法会带来欠拟和的风险，因为虽然当前分支的划分不会带来泛华能力的提升，但在此基础上进行的后续划分却有可能导致性能的显著提升。

后剪枝，是在训练集上生成一棵完整的决策树，然后自底向上将非叶节点的子树替换为叶节点，然后使用验证集计算划分前后的泛华能力，这种替换要一直持续到到根节点为止。

后剪枝的泛化性能通常更好，但是起训练时间开销旺旺更大。

## 5、 连续值处理

对于连续值属性，我们通常利用二分法将其进行离散化处理，假设训练集D中的连续值属性a有n个值，通常我们设置候选划分点集合为：
$$
T_a=\{\frac{a^i+a^{i+1}}{2} | 1\leq i \leq n-1\}
$$
对连续值属性a基于划分点t进行二分后的信息增益计算如下:
$$
\begin{split}
Gain(D, a) =& \max \limits_{t\in T_a}Gain(D, a, t)\\
=&\max \limits_{t\in T_a}Ent(D)- \sum_{\lambda \in \{-,+\}} \frac{|D_t^{\lambda}|}{|D|}Ent(D_t^\lambda)
\end{split}
$$
与离散属性不同，若当前节点划分属性为连续属性，该属性还可作为起后代节点的划分属性。

## 6. 缺失值处理

对于属性包含缺失值的训练样本，我们需要解决两个问题:(1)如何选择划分属性，（2）给定划分属性，如何对属性值缺失的样本进行划分。

对于第一个问题，我们通常利用无缺失值的样本集合$\tilde{D}$来进行选择。

下面先定义几个符号:

* $\tilde{D}$表示D中在属性a上没有缺失值的子样本。

* 我们为每个样本$\textbf{x}$赋予一个权重$w_x$，初始值为1,下面的V表示有多少个类别，|y|表示属性有多少个取值;

* $$
  \rho=\frac{\sum_{x\in\tilde{D}}w_x}{\sum_{x \in D}w_x}\\
  \tilde{p}_k=\frac{\sum_{x\in\tilde{D}_k}w_x}{\sum_{x \in \tilde{D}}w_x}\\
  \tilde{r}_v=\frac{\sum_{x\in\tilde{D}_v}w_x}{\sum_{x \in \tilde{D}}w_x}\\
  $$


可以直观地理解，$\rho$表示无缺失值样本所占比例，$\tilde{p}_k$表示无缺失值样本中dik类所占的比例。$\tilde{r}_v$表示无缺失值样本中在属性a上取值为$a^v$的样本所占的比例。

利用这些定义，计算信息增益:
$$
\begin{split}
Gain(D, a)=&\rho * Gain(\tilde{D}, a)\\
=&\rho * (Ent(\tilde{D})-\sum_{v=1}^v \tilde{r}_v Ent(\tilde{D}_v))
\end{split}
$$
其中:
$$
Ent(\tilde{D})=-\sum_{k=1}^{|y|}\tilde{p}_k log_2\tilde{p}_k
$$
对于问题二，对于样本取值存在的样本，将其划入相应的子节点中即可，切权重保持为$w_x$, 若样本取值未知，则将起划入每个分支，其权重变为$\tilde{r}_v*w_x$

## 7、 多变量决策树

前面提到的选择划分属性都是爱单个属性上进行划分，他的分类边界和坐标轴平行，当进行复杂分类时，这种计算是非常耗时的，可以在单个节点上对多个属性进行线性组合进行测试，这样就会实现斜划分，这种方法生成的树叫做多变量juec